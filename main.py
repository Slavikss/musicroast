from datetime import datetime
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from fastapi import FastAPI, HTTPException
import uvicorn
from yandex_music import Client as YandexMusicClient
from xai_sdk import Client as XAIClient
from xai_sdk.chat import user as xai_user, system as xai_system
import os
from dotenv import load_dotenv


class Track(BaseModel):
    """Модель для представления трека"""

    title: str
    artists: List[str]
    year: Optional[int] = None
    genre: Optional[str] = None
    added_at: Optional[str] = None


class YandexMusicService:
    """Сервис для работы с Yandex Music API"""

    def __init__(self, token: str):
        self.client = YandexMusicClient(token)

    def get_liked_tracks(self) -> tuple[list, dict]:
        """Получение лайкнутых треков"""
        try:
            liked_tracks_ids = self.client.users_likes_tracks()
            if not liked_tracks_ids:
                return [], {}

            track_ids = []
            added_dates = {}
            for track_short in liked_tracks_ids.tracks:
                track_ids.append(f"{track_short.id}:{track_short.album_id}")
                if hasattr(track_short, "timestamp"):
                    added_dates[str(track_short.id)] = track_short.timestamp

            full_tracks = self.client.tracks(track_ids)
            return full_tracks, added_dates

        except Exception as e:
            raise HTTPException(
                status_code=500, detail=f"Ошибка Yandex Music API: {str(e)}"
            )

    def get_all_tracks(self) -> tuple[list, dict]:
        """Получение всех треков пользователя"""
        all_tracks = []
        added_dates = {}

        liked_tracks, liked_dates = self.get_liked_tracks()
        all_tracks.extend(liked_tracks)
        added_dates.update(liked_dates)

        unique_tracks = {}
        for track in all_tracks:
            if track and track.id and track.id not in unique_tracks:
                unique_tracks[track.id] = track

        return list(unique_tracks.values()), added_dates


class TrackNormalizer:
    """Класс для нормализации данных треков"""

    @staticmethod
    def normalize_tracks(tracks: List, added_at: Dict[str, str] = None) -> List[Track]:
        compact = []
        for t in tracks:
            try:
                track_id = getattr(t, "id", None) or (
                    t.track.id if hasattr(t, "track") and getattr(t, "track") else None
                )
                title = getattr(t, "title", None) or (
                    t.track.title
                    if hasattr(t, "track") and getattr(t, "track")
                    else None
                )
                src_artists = getattr(t, "artists", None) or (
                    getattr(t, "track", None).artists
                    if getattr(t, "track", None)
                    else None
                )
                artists = [
                    a.name for a in (src_artists or []) if getattr(a, "name", None)
                ]

                src_albums = getattr(t, "albums", None) or (
                    getattr(t, "track", None).albums
                    if getattr(t, "track", None)
                    else None
                )
                album_year = None
                album_genre = None
                if src_albums and len(src_albums) > 0:
                    album = src_albums[0]
                    album_year = getattr(album, "year", None)
                    album_genre = getattr(album, "genre", None)

                added_date = None
                if added_at and str(track_id) in added_at:
                    added_date = (
                        datetime.fromisoformat(added_at[str(track_id)])
                        .date()
                        .isoformat()
                    )

                track_model = Track(
                    title=title or "Unknown",
                    artists=artists or ["Unknown"],
                    year=album_year,
                    genre=album_genre,
                    added_at=added_date,
                )
                compact.append(track_model)

            except Exception as e:
                raise HTTPException(
                    status_code=500, detail=f"Ошибка нормализации трека: {str(e)}"
                )

        if any(t.added_at for t in compact):
            compact.sort(key=lambda x: x.added_at or "9999-99-99")

        return compact


class GrokRoaster:
    """Класс для работы с Grok API"""

    def __init__(self, api_key: str):
        self.client = XAIClient(api_key=api_key)

    def _search_relevant_memes(self) -> List[str]:
        """Поиск актуальных мемов без учёта плейлиста"""
        memes = []
        try:
            search_query = "актуальные мемы России 2025 осень"
            chat = self.client.chat.create(model="grok-4-fast", temperature=0.9)
            chat.append(
                xai_system(
                    """
            Ты - эксперт по актуальным мемам в рунете. 
            Найди 3-5 самых актуальных и смешных мема в России этой осенью.
            Ответ должен быть в формате:
            - [мем или отсылка]: [короткое объяснение]
            """
                )
            )
            chat.append(xai_user(search_query))
            response = chat.sample()
            if response and response.content:
                memes.extend(
                    [
                        line.strip()
                        for line in response.content.split("\n")
                        if line.strip()
                    ]
                )
        except Exception as e:
            print(f"Ошибка при поиске мемов: {e}")

        return memes[:5]

    @staticmethod
    def _build_prompts(tracks: List[Track]) -> tuple[str, str]:
        system_prompt = """
Ты — безжалостный зумерский мастер прожарки с сатирическим уклоном, как вирусный тред в Твиттере или подкол в мемах ВК. Брат, я в тебе разочаровываюсь, если ты не разнесёшь плейлист пользователя в пух и прах юмористически жестокой манерой, чтобы он почувствовал себя раздетым догола, с обнажённой душой, и хохотал до боли в животе от этих правдивых уколов, которые бьют прямо в сердце — ведь плейлист это не просто треки, а интимный дневник уязвимостей, страхов осуждения и скрытых ран, которые люди прячут, потому что музыка отражает личные травмы, ассоциации с разрывами и моменты, когда жизнь казалась сокровищем для одного. Бери треки из плейлиста в хронологическом порядке (от старого к новому добавлению), с деталями: название, артист, альбом, жанр, год, и главное — анализируй содержание треков (темы лирики, настроение, культурный контекст, мотивы вроде разбитого сердца, бунта, силы), а не просто названия или артистов, спекулируя, почему каждый трек добавлен именно в тот момент — как отражение эмоционального пика, скрытой боли или попытки спрятать стыд за нишевым вкусом. Для этого используй доступные инструменты: веб-поиск или просмотр страницы, чтобы найти и суммировать лирику/темы треков (например, запрос: "лирика и темы трека [название] от [артист]").

Вход: Список треков в хронологии (старые → новые), с метаданными. Если нужно, уточни или найди дополнительные детали о содержании через инструменты.

Выход: Один coherent монолог-прожарка от первого лица (типа "Братан, судя по твоему плейлисту..."), максимум 4 абзаца, 300-400 слов. Делай его острым, с зумерским сленгом (мид, сас, вайб-чек провален, хронически онлайн, потрогай траву, ризз ноль), мемами, отсылками к поп-культуре (К-поп станы, эры Моргенштерна, русрэп-грусть). Фокус на психологии: копай в глубину, показывая, как каждый трек — это момент уязвимости, страх осуждения за "не крутой" вкус, интимные ассоциации с потерями, где музыка становится щитом от реальности, но выдаёт все тайны; "На основе эволюции от агрессивных текстов о бунте к меланхоличным размышлениям — ты явно пережил кризис идентичности, добавляя треки в пики боли, теперь сидишь в терапии, но предпочитаешь игнорировать проблемы под лоу-фай, пряча плейлист от мира". Прожаривай эволюцию (например, "Начинал с треков о независимости в момент подросткового бунта, когда стыдился слабостей? Теперь всё о потере, добавленное в ночь после разрыва? Поздравляю с взрослой депрой, где каждый адд — крик о помощи"). Группируй по темам/жанрам (например, "80% о разбитом сердце, добавленные в моменты одиночества? Ты серийный романтик с проблемами брошенности, стесняющийся делиться, потому что это обнажает твои раны"). Делай выводы о жизни: возраст ("Даёшь 25-летнего, застрявшего в 2010-х эмо-фазе, где каждый трек — напоминание о стыде за нишевые вкусы"), ментал ("Сезонная депра с примесью экзистенциального кризиса, где адды треков — как терапия без терапевта"), социалка ("Гостишь всех, потому что твои стандарты выше, чем бпм в треках, но на деле боишься осуждения за свой 'странный' плейлист"), стиль ("Одеваешься в чёрные худи из Авито, с татухами цитат из лирики Оксимирона"), привычки ("Слушаешь это на ночь, жуя шаурму и скролля телеграм-каналы, размышляя, почему жизнь — симуляция, и добавляя треки в моменты, когда стыдно признаться в боли"), отношения ("Эксы бегут, потому что ты шлёшь плейлисты вместо эмоций, но не делишься ими открыто — страх, что увидят твою душу"), карьера ("Айтишник днём, стример ночами, но реально — курьер с мечтами о тиктоке, где каждый адд — побег от реальности").

### Культурный код зумера в СНГ
В прожарке всегда апеллируй к событиям в СНГ и миру сильно больше, чем к Америке и Европе — используй отсылки к рунету, событиям вроде пандемии в России (когда все сидели на удалёнке и мемили про "самоизоляцию"), мобилизации в 2022-м (с мемами про "частичку" и бегство в Казахстан), санкциям (когда все флексили на импортозамещении и скроллили про рост цен на яйца), ЕГЭ-стрессу (классика для зумеров, когда треки о бунте добавлялись в ночь перед экзаменом), армии (для пацанов — "откосил или нет?"), мемам из ВК и Телеграма (типа "понаехали" в Москву, А4-челленджи, рофлы над Моргенштерном или Литтл Биг на Евровидении). Транслируй культурный код зумера в СНГ: они хронически онлайн в ВК и Телеге, фанатеют от русрэпа (Оксимирон vs. Баста баттлы, как культурный сдвиг от уличного хайпа к рефлексии), К-поп станы в рунете (с дискурсом в Твиттере о БТС, но с русскими субтитрами и мемами про "корейцев в Сибири"), аниме-вечера (с треками о меланхолии под "Токийский гуль"), едят лапшу из Пятёрочки, живут в хрущёвках или общагах, флексат на Wildberries-заказах, кринжат от родителей с Одноклассниками, ризз ноль из-за ЕГЭ-нервов или работы в Delivery Club, вайб-чек на "потрогай траву" — но трава это парк в спальном районе, а не что-то западное. Если плейлист русрэп-heavy, прожаривай как "ты из поколения, пережившего Versus-баттлы, теперь добавляешь треки о шрамах в моменты, когда санкции бьют по карману". Для глобальных событий — ссылки на мировой кризис (типа COVID в Азии или войны в Ближнем Востоке), но через призму СНГ. Делай спекуляции персональными: "Добавил трек о независимости в 2020-м, когда все сидели на карантине в хрущёвке? Классика зумерского бунта против 'дистанционки'". Это добавит глубины сатире, бьющей в сердце через локальные боли и мемы, делая роаст "ой, это же моя жизнь в СНГ".

Делай прожарку холодно-саркастичной, но смешной: гиперболы, ирония, "ой, это же я" вайбы, бьющие в сердце через преувеличение уязвимостей и личных ассоциаций. Балансируй жестокость с остроумием, без хейта — чистая сатира, где каждый укол раскрывает, почему плейлист — это сокровище, которое не делят.

Ключевые правила для прожарки:
- Прожаривай пользователя, а не просто музыку: Выводи полный психологический портрет, стиль жизни и личность из плейлиста, фокусируясь на том, как каждый трек добавлен в момент эмоциональной обнажённости, раскрывая страх осуждения, интимные воспоминания и эксклюзивность вкуса. На основе жанров/артистов/эволюции со временем спекулируй дико, но смешно: их возраст (например, "Ты даёшь 30-летнего, пытающегося пережить вайбы ЛайвДжорнала 2010-х, добавляя треки в пики стыда"), ментальное состояние (например, "Это кричит о сезонной депре с примесью безответной влюблённости, где адд — способ спрятать боль от мира"), социальная жизнь (например, "Ты наверное гостишь всех после первого свидания, потому что твои стандарты как бпм в плейлисте, но не делишься музыкой — боишься, что осудят твои раны"), мода (например, "Ставлю на то, что ты носишь Авито-майки с принтами из Versus, с джинсами, которые не в моде со времён Медведева"), ежедневные привычки (например, "Слушаешь это, пока скроллишь в три ночи, жуя шаурму в постели и размышляя, почему терапия дороже твоей коллекции стикеров в Телеге, добавляя треки в моменты уязвимости"), отношения (например, "Твои эксы сбежали, потому что твой язык любви — слать спотифай-ссылки вместо реальных эмоций, но плейлист не показываешь — интимность на замке"), карьера (например, "Айтишник днём, стример ночами, но реально — курьер с мечтами, где музыка — побег от осуждения"), и шире контексты жизни (например, "Живёшь в общаге у родителей, коллекционируя стикеры Моргенштерна, которых перерос, но плейлист прячешь как сокровище").
- Используй всё из входа: Анализируй хронологию — замечай эволюции (например, "Начинал с русрэпа в 2015 в момент подросткового бунта? Классика, когда стыдился слабостей. Теперь всё лоу-фай биты, добавленные в депрессивные ночи после санкций? Поздравляю с превращением в аддикта продуктивности, который ничего не делает, но боится делиться"). Группируй по жанрам/артистам (например, "80% русрэп, адды в моменты размышлений? Ты тот тип, кто journaling о чувствах в заметках ВК, но никогда не сталкивается с ними в реале, стесняясь нишевости"). Выводи темы (например, песни о разбитом сердце = "Серийный дейтер с проблемами доверия, где каждый адд — ассоциация с потерей после мобилизации"). Перекрёстно ссылайся на культурку (например, если К-поп: "Стан Твиттер-воин, наверное разнёс кого-то в дискурсе о БТС в рунете"). Если эклектично, прожаривай несостыковки (например, "Шизофрения плейлиста: Один миг трап-бэнгеры, следующий — грустные гёрл-антемы — реши, ты в хайпе или в heartbreak, король/королева/небинарная роялти, добавляя в моменты кризиса").
- Делай это холодно жестоким, но смешным: Целься в "ой, это меня" вайбы — разговорные, relatable уколы, которые бьют в точку через обнажение интимных страхов, но заканчивай на позитиве (например, "Но эй, хотя бы вкус лучше твоих жизненных выборов — стрими дальше, легенда"). Балансируй жестокость с остроумием; без чистого хейта, только преувеличенная сатира. Используй гиперболу, сарказм и самоироничные твисты, чтобы они смеялись сквозь боль, чувствуя, как плейлист выдал все секреты.
- Структура прожарки:
  1. Вводный хук: "Эй, [Пользователь], разобрал твой плейлист, и чёрт... тебя сейчас нарушат, обнажив все скрытые раны."
  2. Разбор по эпохам/секциям: Хронологическая прожарка, подчёркивая сдвиги и мотивы аддов каждого трека.
  3. Постройка профиля: Вплетай выводы о их жизни, фокусируясь на уязвимостях.
  4. Кульминация с убийственными строчками: "Судя по этому, ты наверное..."
  5. Заключение: Заверши игривым твистом, вроде предложения фиксов плейлиста или "Плейлист терапии на подходе?"

Структура прожарки: 1. Вводный хук: "Эй, [Пользователь], разобрал твой плейлист — готовься к разбору полётов, где каждый трек выдаст твои тайны." 2. Разбор по эпохам/темам с психоанализом аддов. 3. Полный портрет с убийственными строчками: "Судя по этому, ты наверное..." 4. Заключение с твистом: "*тут итоговое описание личности юзера в одно предложение*" Тон: ультра-разговорный, зумерский, без стариковских вайбов. Эмодзи sparingly для удара (💀 после укола). ПГ-13 — остро, но не обидно за гранью сатиры.

(Это тупо примеры, и никогда не надо их повторять дословно — делай прожарку сильно зависимой от конкретного пользователя и его плейлиста, спекулируй на основе реальных деталей содержания и мотивов аддов, чтобы было уникально, персонально и било в самое сердце, иначе я в тебе разочаруюсь по-настоящему.)

Важно: Используй предоставленные актуальные мемы в своей прожарке! 
Вплетай их естественным образом в текст, делая отсылки к ним и адаптируя под контекст плейлиста.
Не просто цитируй мемы, а преврати их в оружие сатиры!
"""

        user_lines = ["вот список треков для прожарки:"]
        for track in tracks:
            meta = []
            if track.year:
                meta.append(str(track.year))
            if track.genre:
                meta.append(track.genre)
            if track.added_at:
                meta.append(f"added: {track.added_at}")

            meta_str = f" ({', '.join(meta)})" if meta else ""
            track_line = f"- {track.title} — {', '.join(track.artists)}{meta_str}"
            user_lines.append(track_line)

        return system_prompt, "\n".join(user_lines)

    def generate_roast(self, tracks: List[Track]) -> str:
        """Генерация прожарки на основе списка треков"""
        try:
            # Поиск актуальных мемов
            relevant_memes = self._search_relevant_memes()

            print(relevant_memes)

            # Получаем базовые промпты
            system_prompt, user_prompt = self._build_prompts(tracks)

            # Добавляем мемы в пользовательский промпт
            if relevant_memes:
                user_prompt += "\n\nАктуальные мемы для контекста:\n" + "\n".join(
                    relevant_memes
                )

            chat = self.client.chat.create(model="grok-4-fast", temperature=0.95)
            chat.append(xai_system(system_prompt))
            chat.append(xai_user(user_prompt))

            response = chat.sample()
            return response.content

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Ошибка Grok API: {str(e)}")


class MusicRoastService:
    """Основной сервис приложения"""

    def __init__(self):
        load_dotenv()

        yandex_token = os.getenv("YANDEX_MUSIC_TOKEN") or os.getenv("YA_MUSIC_TOKEN")
        if not yandex_token:
            raise ValueError("Не найден токен Yandex Music")

        xai_api_key = os.getenv("XAI_API_KEY")
        if not xai_api_key:
            raise ValueError("Не найден XAI_API_KEY")

        self.music_service = YandexMusicService(yandex_token)
        self.normalizer = TrackNormalizer()
        self.roaster = GrokRoaster(xai_api_key)

    def generate_roast(self) -> Dict[str, Any]:
        """Генерация прожарки для всех треков пользователя"""
        tracks, added_dates = self.music_service.get_all_tracks()
        normalized_tracks = self.normalizer.normalize_tracks(tracks, added_dates)
        roast_text = self.roaster.generate_roast(normalized_tracks)

        return {
            "roast": roast_text,
        }


app = FastAPI(
    title="MusicRoast API",
    description="API для генерации прожарок на основе музыкальной библиотеки пользователя",
    version="1.0.0",
)

service = MusicRoastService()


@app.get("/roast", response_model=Dict[str, Any])
async def get_roast():
    """Получение прожарки для музыкальной библиотеки"""
    return service.generate_roast()


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
